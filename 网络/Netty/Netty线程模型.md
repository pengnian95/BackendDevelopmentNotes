# Netty线程模型

单线程模型
所有I/O操作都由一个线程完成，即 ::多路复用、事件分发和处理都是在一个Reactor线程上完成的:: ，一个 Reactor 线程就是一个 NIO 线程。
![][image-1]
Reactor 单线程模型使用的是一个 NIO 线程， NIO 使用的是非阻塞 I/O，所有的 I/O 操作都不会阻塞，所以 _一个线程可以处理多个 TCP 连接请求_ 。
对于一些小容量应用场景，可以使用单线程模型，但是对于::高负载、大并发::的应用却不合适，主要原因如下：
* 一个NIO线程同时处理成百上千的链路，性能上无法支撑。即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；
* 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接::超时::，超时之后往往进行重发，这更加重了NIO线程的负载，最终导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈；
* 可靠性问题。一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部信息，造成节点故障。

---- 
## 多线程模型
Reactor多线程模型与单线程模型最大区别就是有一组 NIO 线程处理 I/O 操作，它的特点如下：
* 有一个专门的 NIO 线程用于监听服务端，接收客户端的TCP连接请求；
* 网络I/O读、写操作等由一个NIO线程池负责，线程池可以采用标准的 JDK 线程池实现（Netty 扩展了 JDK 线程池），它包含一个任务队列和N个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；
* 1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。
![][image-2]

在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。
例如百万客户端并发连接，或者服务端需要对客户端的握手信息进行安全认证，认证本身非常损耗性能。这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型—主从Reactor多线程模型。
应用：长连接，且客户端数量较少，连接持续时间较长情况下使用。如：企业内部交流应用。

---- 
## 主从多线程
服务端用于接收客户端连接的不再是1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到I/O线程池（sub reactor线程池）的某个I/O线程上，由它负责SocketChannel的读写和编解码工作。
Acceptor线程池只用于客户端的登录、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的I/O线程上，有I/O线程负责后续的I/O操作。
![][image-3]

应用：长连接，客户端数量相对较多，连接持续时间比较长的情况下使用。如：对外提供服务的相册服务器。

[image-1]:	https://raw.githubusercontent.com/zhangpengnian/ImageRepository/master/img/20191010145017.png
[image-2]:	https://raw.githubusercontent.com/zhangpengnian/ImageRepository/master/img/20191010145108.png
[image-3]:	https://raw.githubusercontent.com/zhangpengnian/ImageRepository/master/img/20191010145122.png
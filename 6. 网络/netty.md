# Netty
#6. 网络/RPC#
[Netty - 简书](https://www.jianshu.com/p/b44f98b90077)
- [ ] 待完善
- - - -
Netty是由JBOSS提供的一个Java开源框架。Netty提供::异步的、事件驱动的::网络应用程序框架和工具，用以 _快速开发高性能、高可靠性的网络服务器和客户端程序_ 。
Netty 是一个::基于NIO的客户、服务器端编程框架::，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。
- - - -
## 架构
Netty 采用了比较典型的三层网络架构进行设计，逻辑架构图如下所示：
![](Netty/(null))![](Netty/(null))
![](Netty/F956B150-7ADA-4854-BD8A-B39775D89E23.png)

* 第一层，::Reactor 通信调度层::，它由一系列辅助类完成，包括 Reactor 线程 NioEventLoop 以及其父类、NioSocketChannel/NioServerSocketChannel 以及其父 类、ByteBuffer 以及由其衍生出来的各种 Buffer、**Unsafe以及其衍生出的各种内部类**等。该层的主要职责就是::监听网络的读写和连接操作::，负责将网络层的数据 读取到内存缓冲区中，然后触发各种网络事件，例如连接创建、连接激活、读事 件、写事件等等，将这些事件触发到 PipeLine 中，由 PipeLine 充当的职责链来 进行后续的处理。
* 第二层，::职责链PipeLine::，它::负责事件在职责链中的有序传播，同时负责动态的编排职责链::，职责链可以选择监听和处理自己关心的事件，它可以拦截处理和向 后/向前传播事件，不同的应用的 Handler 节点的功能也不同，通常情况下，往往 会开发编解码 Hanlder 用于消息的编解码，它可以将外部的协议消息转换成内部 的 POJO 对象，这样上层业务侧只需要关心处理业务逻辑即可，不需要感知底层 的协议差异和线程模型差异，实现了架构层面的分层隔离。
* 第三层，::业务逻辑处理层::。可以分为两类:
	1. 纯粹的业务逻辑处理，例如订单处理。
	2. 应用层协议管理，例如HTTP协议、FTP协议等。
- - - -
## 线程模型
Netty中支持单线程模型，多线程模型，主从多线程模型。
在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。
为了尽可能提升性能，Netty采用了串行无锁化设计，在I/O线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。

### Reactor单线程模型
在ServerBootstrap调用方法group的时候，传递的参数是同一个线程组，且在构造线程组的时候，构造参数为1，这种开发方式，就是一个单线程模型。
个人机开发测试使用。不推荐。

### Reactor多线程模型
在ServerBootstrap调用方法group的时候，传递的参数是两个不同的线程组。负责监听的acceptor线程组，线程数为1，也就是构造参数为1。负责处理客户端任务的线程组，线程数大于1，也就是构造参数大于1。这种开发方式，就是多线程模型。
长连接，且客户端数量较少，连接持续时间较长情况下使用。如：企业内部交流应用。

### Reactor主从多线程模型
在ServerBootstrap调用方法group的时候，传递的参数是两个不同的线程组。负责监听的acceptor线程组，线程数大于1，也就是构造参数大于1。负责处理客户端任务的线程组，线程数大于1，也就是构造参数大于1。这种开发方式，就是主从多线程模型。
长连接，客户端数量相对较多，连接持续时间比较长的情况下使用。如：对外提供服务的相册服务器。
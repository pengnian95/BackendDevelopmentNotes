# TCP的连接管理
#6. 网络/TCP#
- - - -
## 三次握手
![](TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpeg)
1. 假设 A 为客户端，B 为服务器端。
2. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 
3. A 向 B 发送连接请求报文，**SYN=1，ACK=0**，选择一个**初始的序号 x**。 
4. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，**SYN=1，ACK=1，确认号为 x+1**，同时也选择一个**初始的序号 y**。 
5. A 收到 B 的连接确认报文后，还要向 B 发出确认，**确认号为 y+1，序号为 x+1**。
6. B收到 A 的确认后，连接建立。

## 三次握手的原因
第三次握手是为了**防止失效的连接请求到达服务器，让服务器错误打开连接**。
客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待 一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握 手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确 认，不进行第三次握手，因此就不会再次打开连接。
- - - -
## 四次挥手
![](TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/E8FFE831-458C-4067-A8CB-9B0E858A6D7C.png)
以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 **ACK 在连接建立之后都 为 1**。
1. A 发送连接释放报文，FIN=1。 
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 
3. 当 B 不再需要连接时，发送连接释放报文，FIN=1。
4. A收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 
5. B 收到 A 的确认后释放连接。

## 四次挥手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 `CLOSE-WAIT` 状态。这个状态是为了让服 务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。
- - - -
## TIME_WAIT
1. 确保最后一个**确认报文能够到达**。如果B没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 
2. 等待一段时间是为了**让本连接持续时间内所产生的所有报文都从网络中消失**，使得下一个新的连接不会出现旧的连接请求报文。

## 出现大量的TIME_WAIT
在::高并发短连接::的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。
为什么我们要关注这个高并发短连接呢？有两个方面需要注意：
	1. ::高并发::可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。
	2. 在这个场景中，::短连接::表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。
### 解决方案
打开系统的TIME_WAIT重用和快速回收。
编辑内核文件_etc_sysctl.conf，加入以下内容：
```
net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间
```
然后执行 _sbin_sysctl -p 让参数生效。
```
/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。
```


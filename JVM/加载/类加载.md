# 类加载

## JVM的类加载机制

- 类的加载指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在运行时数据区的**方法区**内，然后在**堆区**创建一个`java.lang.Class`对象，用来封装类在方法区内的数据结构。类的加载的**最终产品是位于堆区中的Class对象**，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
- 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就**预先加载**它。

![类被加载后在占内存中的分布情况][image-1]

- **全盘负责**：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
- **父类委托**：先让父类加载器试图加载该类，**只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类**
- **缓存机制**：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

### 三种类加载方式
1. 命令行启动应用时候由JVM初始化加载
2. 通过`Class.forName()`方法动态加载
3. 通过`ClassLoader.loadClass()`方法动态加载

---- 

## 类加载的顺序
**普通代码块**（局部代码快）是在方法名后面用`{}`括起来的代码段，不能够单独存在，必须要紧跟在方法名后面且必须使用方法名调用它，作用是限定变量的生命周期和提高效率。
**构造代码块**是在类中方法外用`{}`括起来的代码，作用是把所有构造方法中相同的内容抽取出来，将来在调用构造方法的时候会去自动调用构造代码块，**构造代码快优先于构造方法**。
**静态代码块**是在类中方法外用`{}`括起来且添加了 static 前缀修饰的代码，作用是随着类的加载而加载且只加载一次。
**同步代码块**是方法中使用 synchronized 关键字修饰并使用`{}`括起来的代码片段，表示同一时间只能有一个线程进入到该代码块中，作用是一种多线程并发保护机制。
他们三者的**执行顺序**为：**静态代码块 \> 构造代码块 \> 构造方法。**
涉及到**继承**时的顺序为：
1. 父类静态代码块
2. 子类静态代码块
3. 父类构造代码块
4. 父类构造函数
5. 子类构造代码块
6. 子类构造函数
---- 
## 双亲委派模型
 四种类加载器
1. 启动类加载器
2. 拓展类加载器
3. 应用程序类加载器
4. 自定义类加载器
### 流程
某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
---- 
## 类的生命周期
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载
其中，1、2、3、5顺序确定。
---- 
## 类加载的具体步骤
### 一、加载
1. 通过一个类的全限定名来获取定义此类的二进制字节流，JVM把这个阶段的动作放在了虚拟机外部的“类加载器”中实现。未指明从哪里获取，因此有各种花样，比如从JAR包、WAR包，或者网络，或者运行时计算生成等等。
2. 将这个字节流所代表的的静态存储结构转化为**方法区**的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。即*对象类型数据（非对象实例数据）存在方法区*。

### 二、验证
验证的目的是确保Class文件的字节流中包含的信息*不会危害虚拟机自身的安全*，直接决定了Java虚拟机是否能承受恶意代码的攻击。
验证阶段分为4个
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符合引用验证

### 三、准备
准备阶段**为类变量在方法区中分配内存并设置类变量的零值**
1. 这里只包含**类变量（即被static修饰的变量）**，而不是实例变量
2. 实例变量会在对象实例化时随着对象一起分配在Java堆中
3. 比如 public static int value =123;在准备阶段过后value=0，只有在初始化阶段之后，value才等于123。

### 四、解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
1. 符号引用也是描述所引用目标的，但引用的目标并不一定已经加载在内存中
2. 直接引用是指针、句柄这种，直接引用的目标必定以及在内存中存在。

### 五、初始化
初始化时类加载的最后一步，根据程序员的主观去*初始化类变量和其他资源*

[image-1]:	https://raw.githubusercontent.com/zhangpengnian/ImageRepository/master/img/20191007193211.png
# 垃圾收集器
* *Serial*：最早的::单线程::串行垃圾回收器。
* *SerialOld：Serial*垃圾回收器的::老年::版本，同样也是单线程的，可以作为CMS垃圾回收器的备选预案。
* *ParNew*：是Serial的::多线程::版本。
* *Parallel*和ParNew收集器类似是多线程的，但Parallel是::吞吐量优先::的收集器，可以牺牲等待时间换取系统的吞吐量。
* *ParallelOld*是Parallel老生代版本，Parallel使用的是复制的内存回收算法，ParallelOld使用的是标记-整理的内存回收算法。
* *CMS*：一种以获得::最短停顿时间::为目标的收集器，非常适用B/S系统。
* *G1*：一种兼顾吞吐量和停顿时间的GC实现，是JDK9以后的默认GC选项。
---- 
## 新生代收集器
### Serial
最基本、发展历史最久的收集器，这个收集器是一个采用::复制::算法的::单线程::的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着 _它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止_ 。后者意味着，在用户不可见的情况下要把用户正常工作的线程全部停掉，这对很多应用是难以接受的。不过实际上到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它::简单而高效::。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。

### ParNew
ParNew收集器其实就是::Serial收集器的多线程版本::，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作（看图）。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用`-XX:ParallelGCThreads`参数来限制垃圾收集的线程数。

### Parallel Scavenge
Parallel Scavenge收集器也是一个新生代收集器，也是用::复制算法::的收集器，也是::并行::的多线程收集器，但是它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍吞吐量的概念。CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是::达到一个可控制的吞吐量::。 _所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）_ ，虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，Parallel Scavenge收集器是虚拟机运行在Server模式下的默认垃圾收集器。
---- 
## 老年代收集器
### Serial Old
::Serial收集器的老年代版本::，同样是一个单线程收集器，使用::标记-整理算法::，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。

### Parallel Old
Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。

### CMS
CMS（Conrrurent Mark Sweep）收集器是以获取::最短回收停顿时间::为目标的收集器。使用::标记-清除::算法，收集过程分为如下四步：
1. 初始标记，标记GCRoots能直接关联到的对象，时间很短。
	2. *并发*标记，进行GCRoots Tracing（可达性分析）过程，时间很长。
	3. 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。
	4. *并发*清除，回收内存空间，时间很长。
其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。
---
### G1(Garbage-First)
G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。
G1 将整个堆划分为一个个大小相等的小块（每一块称为一个region），每一块的内存是连续的，每个块也会充当 Eden、Survivor、Old三种角色，但是它们不是固定的，这使得内存使用更加地灵活。如下图所示
![]()
执行垃圾收集时，收集线程在标记阶段和应用程序线程并发执行，标记结束后，G1 也就知道 _哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，_ 这也是为什么 G1 被取名为 Garbage-First 的原因。
与其他GC收集器相比，G1收集器有以下::特点::：
1. 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。
2. 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。
3. 空间整合。基于标记 - 整理算法，无内存碎片产生。
4. 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
---- 
## 不同版本的JDK使用的垃圾收集器
1. JDK1.8
Parallel Scavenge（新生代）+ Serial Old（老年代）
2. JDK1.9
G1


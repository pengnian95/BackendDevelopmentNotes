# 索引
#4. 数据库/索引#
- - - -
##  索引的类型
1. UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值
2. INDEX(普通索引)：允许出现相同的索引内容
3. PROMARY KEY(主键索引)：不允许出现相同的值
4. fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维
5. 组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一

## 特点
优点：
	1. 1. 减少了服务器需要扫描的数据量
	2. 避免排序和临时表
	3. 可以将随机I_O变为顺序I_O
适用条件：
	1. 对于**非常小的表**、大部分情况下简单的全表扫描比建立索引更高效； 
	2. 对于中到大型的表，索引就非常有效； 
	3. 但是**对于特大型的表，建立和维护索引的代价将会随之增长**。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 索引方式
	1. [B+树](bear://x-callback-url/open-note?id=36F4D30F-596C-4C6D-B64E-11C334B59AFE-4890-0000608FE8DE67F6)
	2. 哈希索引
	3. 空间数据索引
	4. 全文索引
### B+树的优点
	1. 有利于对数据库的扫描，遍历更快。
	2. 磁盘读写代价更低，非叶子节点内之存储KEY，没有存储实际数据，因此更省空间。
	3. 查询效率更稳定，所有数据都位于叶子节点上。
### 哈希索引 vs. B+树
	1. 哈希索引适合等值查询，但是无法进行范围查询
	2. 没办法利用索引完成排序
	3. 不支持多列联合索引的最左匹配原则
	4. 如果有大量重复键，存在哈希碰撞因此效率很低

## 创建索引的原则
	1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
	2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
	3. 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count()，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
	4. 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);*
	5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

## 创建索引
### ALTER TABLE
```
ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）[索引名]（字段名）
//普通索引
alter table table_name add index index_name (column_list) ;
//唯一索引
alter table table_name add unique (column_list) ;
//主键索引
alter table table_name add primary key (column_list) ;

```
### CREATE INDEX
```
CREATE INDEX index_name ON table_name(username(length)); 
//只能添加这两种索引;
CREATE INDEX index_name ON table_name (column_list)
CREATE UNIQUE INDEX index_name ON table_name (column_list)
```
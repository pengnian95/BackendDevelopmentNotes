# 分布式锁

## 对比（排名靠前表示推荐使用）
- 理解难度：数据库 \> 缓存 \> Zookeeper
- 实现的复杂性：Zookeeper \>= 缓存 \> 数据库
- 性能：缓存\> Zookeeper \>= 数据库
- 可靠性：Zookeeper \> 缓存 \> 数据库

## 基于数据库的分布式锁
### 基于数据库**表**
当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。
```sql
CREATE TABLE `methodLock` ( 
`id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',  
`method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',
`desc` varchar(1024) NOT NULL DEFAULT '备注信息',  
`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',  
PRIMARY KEY (`id`),  
UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
```
当要锁住某个方法时，执行：
```sql
insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)
```
因为我们对`method_name`做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为：操作成功的那个线程获得了该方法的锁，可以执行方法体内容。
当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:
```sql
delete from methodLock where method_name ='method_name'
```
- 存在问题：
	1. 这把锁::强依赖数据库的可用性::，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
	2. 这把锁::没有失效时间::，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
	3. 这把锁::只能是非阻塞::的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
	4. 这把锁是::非重入::的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。
- 解决方式：
	1. 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。
	2. 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
	3. 非阻塞的？搞一个while循环，直到insert成功再返回成功。
	4. 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。
### 基于数据库的**排它锁**
可以借助数据库中自带的锁来实现分布式的锁。在查询语句后面增加`for update`，数据库会在查询过程中给数据库表增加::排他锁::。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。
```java
public boolean lock(){    
    connection.setAutoCommit(false);
    while(true){        
        try{            
            result = select * from methodLock where method_name=xxx for update;            
            if(result==null){                
                return true;           
            }        
        }catch(Exception e){
		}
        sleep(1000);
    }
    return false;
}
```
通过`connection.commit()`操作来释放锁。
这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。
* 阻塞锁？`FOR UPDATE`语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。
* 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。
但是还是无法直接解决::数据库单点::和::可重入::问题。
### 总结
优点：实现简单，容易理解
缺点：性能不好

---- 
## 基于缓存的分布式锁
可以使用::缓存::来代替数据库来实现分布式锁，这个可以提供更好的::性能::，同时，很多缓存服务都是集群部署的，可以::避免单点问题::。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置::超时::时间来控制锁的释放。
### 实现原理
1. 互斥性
- 保证同一时间只有一个客户端可以拿到锁，也就是可以对共享资源进行操作。
1. 安全性
- _只有加锁的服务才能有解锁权限_ ，也就是不能让a加的锁，bcd都可以解锁，如果都能解锁那分布式锁就没啥意义了。
- 可能出现的情况就是a去查询发现持有锁，就在准备解锁，这时候忽然a持有的锁过期了，然后b去获得锁，因为a锁过期，b拿到锁，这时候a继续执行第二步进行解锁如果不加校验，就将b持有的锁就给删除了。
1. 避免死锁
- 出现死锁就会导致后续的任何服务都拿不到锁，不能再对共享资源进行任何操作了。
1. 保证加锁与解锁操作是原子性操作
- 这个其实属于是实现分布式锁的问题，假设a用redis实现分布式锁。
- 假设加锁操作，操作步骤分为两步： 1，设置key set（key，value）2，给key设置过期时间。
- 假设现在a刚实现set后，程序崩了就导致了没给key设置过期时间就导致key一直存在就发生了死锁。
### 使用方式
- 使用redis命令 `set key value NX EX max-lock-time` 实现加锁
- 使用redis命令 `EVAL` 实现解锁
	- 加锁操作：`jedis.set(key,value,”NX”,”EX”,timeOut)`【保证加锁的原子操作】
	- key就是redis的key值作为锁的标识，value在这里作为客户端的标识，只有key-value都比配才有删除锁的权利（保证安全性）
	- 通过timeOut设置过期时间保证不会出现死锁【避免死锁】
	- NX，EX什么意思？
		- NX：只有这个key不存才的时候才会进行操作，if not exists；
		- EX：设置key的过期时间为秒，具体时间由第5个参数决定
### 缺点
Redis分布式锁::不能解决超时的问题::，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

---- 
## 基于ZooKeeper的分布式锁
基于ZooKeeper临时有序节点可以实现的分布式锁。大致思想即为：
1. 每个客户端对某个方法加锁时，在ZooKeeper上的与该方法对应的指定节点的目录下，生成一个唯一的::瞬时有序节点::。
2. 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。
3. 成业务流程后，删除对应的子节点释放锁。
解决的问题：
- *锁无法释放*：使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。
- *非阻塞锁*：使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。
- *不可重入*：使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。
- *单点问题*：使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。


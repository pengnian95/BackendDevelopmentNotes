# RabbitMQ

RabbitMQ是一个由Erlang语言开发的 AMQP 的开源实现。

-*AMQP：Advanced Message Queue**，高级消息队列协议。它是应用层协议的一个开放标准，为 面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言 等条件的限制。

## 组成

### 重要角色

- 生产者：消息的创建者，负责创建和推送数据到消息服务器。
- 消费者：消息的接收方，用于处理数据和确认消息。
- 代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。

### 组件

- ConnectionFactory（连接管理器）：应用程序与RabbitMQ之间建立连接的管理器，程序代码中使用。
- Channel（信道）：消息推送使用的通道。
- Exchange（交换器）：用于接受、分配消息。
- Queue（队列）：用于存储生产者的消息。
- RoutingKey（路由键）：用于把生成者的数据分配到交换器上。
- BindingKey（绑定键）：用于把交换器的消息绑定到队列上。

---- 

## 使用场景

### 跨系统的**异步通信**
所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。

### 多个应用之间的**耦合**
由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。

### 应用内的同步变异步
比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。

### 消息驱动的架构（EDA）
系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。

### 应用需要更灵活的耦合方式
如发布订阅，比如可以指定路由规则。

### 跨局域网，甚至跨城市的通讯（CDN行业）
比如北京机房与广州机房的应用程序的通信。

---- 

## 消息的安全性

### 避免消息丢失
- 消息持久化
- ACK确认机制
- 设置集群镜像模式
- 消息补偿机制

### 保持消息持久化成功的条件
1. 声明队列必须设置持久化 durable 设置为 true.
2. 消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。
3. 消息已经到达持久化交换器。
4. 消息已经到达持久化队列。

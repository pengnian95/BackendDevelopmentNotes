# B-树 & B+树
#5. 数据结构与算法/树#
- - - -
## B-Tree
1. 每个结点最多m个子结点。
2. 除了根结点和叶子结点外，每个结点最少有m/2（向上取整）个**子结点**。
3. 如果根结点不是叶子结点，那根结点至少包含两个子结点。
4. 所有的叶子结点都位于同一层。
5. 每个结点都包含k个**元素（关键字）**，这里m/2≤k<m，这里m/2向下取整。
6. 每个元素（关键字）字左结点的值，都小于或等于该元素（关键字）。右结点的值都大于或等于该元素（关键字）。

## B+Tree
在B-Tree基础上的优化，更适合**外存储索引结构**。
1. 所有的非叶子节点只存储**关键字信息**。
2. 所有**卫星数据（具体数据）**都存在叶子结点中。
3. 所有的叶子结点中包含了全部元素的信息。
4. 所有叶子节点之间都有一个**链指针**。

## B-Tree vs. B+Tree
1. B-Tree因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。而B+Tree所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的B-Tree和B+Tree中，**B-Tree查找某个关键字的效率更高**
2. 由于B+Tree所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的数据的时候，**B+Tree只需要找到该关键字然后沿着链表遍历就可以了**，而B-Tree还需要遍历该关键字结点的根结点去搜索。
3. 由于B-Tree的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而B+Tree非叶子结点只存储关键字信息，而每个页的大小有限是有限的，所以同一页能存储的B-Tree的数据会比B+Tree存储的更少。**这样同样总量的数据，B-Tree的深度会更大，增大查询时的磁盘I/O次数，进而影响查询效率。**

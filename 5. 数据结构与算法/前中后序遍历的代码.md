# 前中后序遍历的代码
#5. 数据结构与算法/树#
- - - -
## 前序遍历
![](%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%BB%A3%E7%A0%81/54261461.png)
- - - -
## 中序遍历
![](%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%BB%A3%E7%A0%81/2354123451.png)
- - - -
## 后序遍历
![](%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%BB%A3%E7%A0%81/999.png)

## 层序遍历
![](%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%BB%A3%E7%A0%81/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(1).png)


## 代码
层序遍历
```
public class Solution {

    ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            ArrayList<Integer> level = new ArrayList<Integer>():
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(Level);
        }
        return result;
    }

}
```



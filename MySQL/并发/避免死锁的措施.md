# 避免死锁的措施
1. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。
2. 在应用中，如果不同的程序会并发存取多个表，应尽量 ::约定以相同的顺序来访问表:: ，这样可以大大降低产生死锁的机会。
3. 在程序以批量方式处理数据的时候，如果 ::事先对数据排序:: ，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。
4. 在事务中，如果要更新记录，应该::直接申请足够级别的锁::，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。
5. 在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用`SELECT ... FOR UPDATE`加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。
6. 当隔离级别为`READ-COMMITTED`时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁。这时如果有第3个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。

# MVCC

Multi-Version Concurrency Control 多版本并发控制
## 概述
* 可以认为MVCC是::行级锁的一个变种::，但是它在很多情况下::避免了加锁操作::，因此开销更低。虽然实现机制所有不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。
* InnoDB的MVCC，是通过 _在每行纪录后面保存两个隐藏的列_ 来实现的。这两个列， _一个保存了行的创建时间，一个保存了行的过期时间，_ （存储的并不是实际的时间值，而是系统版本号）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行纪录的版本号进行比较。

MVCC多版本并发控制是用来解决“::读-写冲突::”的无锁并发控制
* 同一个数据有多个版本，事务开启时看到是哪个版本就看到这个版本，最大的好处是 _读写不冲突，只有写于写是冲突的_ ，这个特性可以很大程度上提升性能，::避免了脏读::

乐观锁是用来解决“*写-写冲突*”的无锁并发控制
* 认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。
---
## 具体流程
在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据::何时被创建::，另外一个记录这行数据::何时过期（或者被删除）::。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 
在可重读**REPEATABLE-READ**事务隔离级别下：
- `SELECT`时，读取创建版本号\<=当前事务版本号，删除版本号为空或\>当前事务版本号。
- `INSERT`时，保存当前事务版本号为行的创建版本号。
- `DELETE`时，保存当前事务版本号为行的删除版本号。
- `UPDATE`时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。
通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以::减少锁的使用::，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也::只锁住必要行::。
# GC

## 哪些对象需要GC
1. JVM栈中引用的对象。
2. 方法区中类静态属性实体引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中JNI[^1]引用的对象。

## 如何确定垃圾
1. 引用计数
采取引用计数是否可行？即统计有多少人引用了，如果0人引用，则判断为垃圾。缺点是：东西很多时，消耗太大；A引用了B，B引用了A，其实A/B都是垃圾，但他们引用永远都是1，不会被回收掉，陷入了死循环。
2. 可达性分析
从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。这也是JVM采用的可达性分析算法。
### 引用类型
1. 强引用
指向对象的引用，不会被gc回收。
2. 软引用
垃圾回收的第二次内存回收需要回收的内存；如果软引用内存释放之后内存还不够，就报内存溢出异常（GC在内存不够时才会回收被引用的对象，内存够的话不会回收）。
3. 弱引用
垃圾回收的第一次内存回收收集回收的内存（GC发生即会回收被引用的对象）。
4. 虚引用
通过虚引用是无法取得一个对象的实例的，等同于没有。存在的目的是，在这个对象被回收的时候，收到一个系统通知。

## GC算法
1. 标记-清除
标记所有要回收的对象，标记完成后统一回收
缺点：
- 标记和清除的效率太低
- 产生大量不连续的内存碎片，导致分配较大的对象时内存空间不够，从而提前触发GC。 	
1. 标记-整理
标记需要回收的对象，将存活对象移动到一端，将端边界以外的内存进行回收。
3. 复制
将内存分为大小相等的两半，每次只有其中一半，一半用完后，将其中不需要GC的对象复制到另一半中，然后将当前一半的内存区域全部进行GC。
* 优点：效率高，存活时间短，其实不需要1:1划分区域（Eden:Survivor=8:1）
	* 缺点：代价高，需要用一半内存。	
4. 分代收集
将堆分为新生代和老年代，新生代只有少量对象存活，用复制，老年代用标记-清除或标记-整理。

[^1]:	JNI：Java Naive Interface，实现了若干Java同其他语言的通信。
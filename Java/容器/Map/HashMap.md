# HashMap

## 底层实现
基于动态数组和链表（拉链法）。链表长度超过8则会变为*红黑树*（JDK1.8开始），长度小于等于6时重新转换为链表。同时，也有一个机制来避免频繁的红黑树和链表的转换。

## 扩容
去除 ::Segment + HashEntry + Unsafe:: 的实现，
改为 ::Synchronized + CAS + Node + Unsafe:: 的实现
### JDK1.7
*所有元素的hash值都需要重新计算。*
取出数组元素（实际数组索引位置上的每个元素是每个独立单向链表的头部，也就是发生 Hash 冲突后最后放入的冲突元素）然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标然后进行交换（即原来 hash 冲突的单向链表尾部变成了扩容后单向链表的头部）。
### JDK1.8
1. 只有一半的元素需要改变位置。
- 按位计算`e.hash&oldCapacity`。如果为0，索引不变。如果为1，索引为oldCapacity+原索引位。
- 因为 hash 值本来就是随机性的，所以 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈西冲突的元素再随机的分布到不同的索引去。
2. 计算hashmap的方式改为：::高16位异或低16位。::

## 遍历
HashMap有四种遍历方式
1. `for each map.entrySet()`
2. 调用`map.entrySet()`的集合迭代器
3. `for each map.keySet()`
4. 临时变量保存`map.entrySet()`，与1类似

* 对于 keySet 实质上是遍历了两次，一次是转为 iterator 迭代器遍历，一次就从 HashMap 中取出 key 所对于的 value 操作（通过 key 值 hashCode 和 equals 索引）
* entrySet 方式只遍历了一次，它把 key 和 value 都放到了 Entry 中，所以效率高。
* HashMap是Faile-fast（详见笔记Fail-fast & Fail-safe））

## 线程安全
### 首尾相接的死循环
JDK1.7 中并发扩容操作可能会导致哈希碰撞的链表结构为循环链表，从而导致在后续 put、get 操作时发生::死循环::：
* Hashmap成环原因的代码出现在transfer代码中，也就是扩容之后的数据迁移部分。
	* transfer的过程：
		* 首先获取新表的长度，之后遍历新表的每一个entry，然后每个ertry中的链表，以反转的形式，形成rehash之后的链表。
	* 并发问题：
		* 若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到`e.next = new table`的时候，由于线程二之前数据迁移的原因导致此时`new table`上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。
[JDK1.8后HashMap多线程下扩容死循环解决  CSDN博客]()
而对于JDK1.8中扩容链表的顺序是不会发生逆向的，所以自然怎么遍历都不会出现循环链表的情况，故 JDK1.8 中不会出现并发循环链表，但由于 JDK1.7 与 JDK1.8 中都是无锁保护的，所以依然是并发不安全的。
### 丢失修改信息
JDK1.7中，发生碰撞后，新的元素会放在链表的头部。如果两个线程同时添加元素，则均会返回当前元素作为头结点的链表，因此另一个线程的修改就会丢失。
### 如何线程安全地使用HashMap？
1. HashTable
2. ConcurrentHashMap
3. SynchronizedMap


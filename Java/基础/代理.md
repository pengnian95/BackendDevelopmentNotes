# 代理

- 静态代理：代理类是在编译时就实现好的。也就是说Java编译完成后代理类是一个实际的class文件。
- 动态代理：代理类是在运行时生成的。也就是说Java编译完成之后并没有生成实际的class文件，而是在运行时动态生成的类字节码，并加载到JVM中。

JDK动态代理是由Java内部的**反射机制+动态生成字节码**来实现的，CGLIB动态代理底层则是借助**asm**来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程 中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：JDK动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，JDK动态代理不能应用。由此可以看出，JDK动态代理有一定的局限性，cglib这种第三方类库实现的动态代理**应用更加广泛**，且在效率上更有优势。

前者必须基于**接口**，后者不需要接口，是基于**继承**的，但是不能代理final类和final方法；

JDK采用**反射机制**调用委托类的方法，CGLIB采用**类似索引的方式**直接调用委托类方法；

前者效率略低于后者效率，**CGLIB效率略高**（不是一定的）。

## JDK动态代理

Proxy类。
（不想看源码。。。）

## CGLIB动态代理

### 原理
1. 生成代理类Class的二进制字节码（基于ASM）。
> ASM是一个Java字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM可以直接产生二进制class文件，也可以在类被加载入Java虚拟机之前动态改变类行为。Javaclass被存储在严格格式定义的.class文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及Java字节码（指令）。ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。说白了asm是直接通过字节码来修改class文件。
2. 通过`Class.forName`加载二进制字节码，生成Class对象。
3. 通过反射机制获取实例构造，并初始化代理类对象。
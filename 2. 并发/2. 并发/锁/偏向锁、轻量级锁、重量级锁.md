# 偏向锁、轻量级锁、重量级锁
#2. 并发/锁#
- - - -
## 偏向锁
* 偏向锁是jdk1.6引入的一项锁优化，其中的“偏”是偏心的偏。它的意思就是说， _这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。_
* 也就是说：在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行**加锁**或者**解锁**操作，而是会做以下的步骤：
	1. Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.
	2. 如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.
	3. 如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。
	4. 如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。
	5. 如果此对象已经偏向了，并且不是偏向自己，则说明存在了**竞争**。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成**轻量级锁**了。
* 可以看出，偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。 _假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。_
* 为什么要这样做呢？因为 _经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的_ 。这也是为什么会有偏向锁出现的原因。
* 在Jdk1.6中，偏向锁的开关是默认开启的，适用于只有一个线程访问同步块的场景。
### 优点
加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距。
### 缺点
如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。
- - - -
## 轻量级锁
* 也被称为**非阻塞同步、乐观锁**，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。
* 主要有两种：
	1. 自旋锁
	2. 自适应自旋锁
### 自旋锁
* 当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给**阻塞**，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。
* 适用于同步代码块执行很快的场景。
* 缺点：
	1. 如果同步代码块执行很慢，那么其他线程在原地消耗CPU资源。
	2. 如果竞争比较激烈，可能消耗更多的CPU资源。
### 自适应自旋锁
线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。
- - - -
## 重量级锁
* 也称为**阻塞同步、悲观锁、互斥锁**
* 轻量级锁膨胀之后，就升级为重量级锁了。 _重量级锁是依赖对象内部的monitor锁来实现的_ ，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为**互斥锁**。
* 当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行**阻塞**，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从**用户态**转换到**内核态**，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。
- - - -
## 应用场景
* 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
* 轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
* 重量级锁：有实际竞争，且锁竞争时间长。

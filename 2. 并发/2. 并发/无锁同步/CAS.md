# CAS
#2. 并发/无锁同步#
 [https://www.cnblogs.com/barrywxx/p/8487444.html](https://www.cnblogs.com/barrywxx/p/8487444.html) 
- - - -
Compare-and-swap
## 锁机制存在的问题
1. 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
2. 一个线程持有锁会导致其它所有需要此锁的线程挂起。
3. 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。

## 流程
1. CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 
2. 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。
3. 无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。
> CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”  

## CAS存在的问题
1. ABA问题。
2. 循环时间开销大。
3. 只能保证一个共享变量的原子操作。

原子类
* AtomicInteger是支持原子操作的Integer类，保证对其的增加和减少都是原子性的。
* 基于::CAS::实现。

## 如何解决ABA问题
1. 版本号
2. AtomicStampedReference
	* `AtomicStampedReference`内部维护了对象值和版本号。创建`AtomicStampedReference`对象时，需要传入初始值和初始版本号。当对象设置对象值时，必须对象值和状态戳都满足期望值，才会写入成功。
3. AtomicMarkedReference
4. 
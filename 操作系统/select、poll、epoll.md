# select、poll、epoll

## Select的三个缺点
1. 连接数受限
2. 查找匹配速度慢
3. 数据由内核态拷贝到用户态 
poll改善了第一个缺点，epoll改善了三个缺点。

## 时间复杂度
1. select==\>时间复杂度O(n)
它仅仅知道了，有I/O事件发生了，却*并不知道是哪那几个流*（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。

2. poll==\>时间复杂度O(n)
poll本质上和select没有区别，它将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态， 但是*它没有最大连接数的限制，原因是它是基于链表来存储的*，因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
 
3. epoll==\>时间复杂度O(1)
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）。

## 如何选择
1. 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2. select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善

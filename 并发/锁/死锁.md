# 死锁

## 必要条件
1. 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
2. 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 
3. 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 
4. 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 出现原因

### 概述
- 因为系统资源不足。
- 进程运行推进的顺序不合适。
- 资源分配不当等。

### 具体原因
1. **交叉锁**：哲学家吃饭问题。
2. **内存不足**：资源并不仅仅是某个对象的锁。
3. **一问一答式的数据交换**：服务器和客户端都在等待对方发送数据。
4. **数据库锁**：情形复杂。
5. **文件锁**：获取了文件锁的某线程意外退出，其他读取该文件的线程会进入死锁直到操作系统释放该文件的句柄资源。
6. **死循环**

## 防止死锁
1. 破坏“占有和等待”
	每个进程在开始执行时就申请他所需要的全部资源。
	每个进程在申请所需要的资源时他本身不占用系统资源。
2. 破坏“不可抢占”
	一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
3. 破坏“循环等待”
	采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。
### 银行家算法
1. 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；
2. 顾客可以分期贷款，但贷款的总数不能超过最大需求量；
3. 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；
4. 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金。
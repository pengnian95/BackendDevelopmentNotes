# volatile

## 对比synchronized
1. **volatile**本质是告诉JVM，当前变量在**寄存器（工作内存）**中的值是不确定的，需要从**主内存**中读取。
2. **synchronized**锁定当前变量，不允许其他线程访问。

## 作用
1. 保证共享变量的**可见性**，不保证**原子性**
2. 禁止**指令重排**优化
3. 并不能保证**原子性**

### 指令重排

重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：
1. 重排序操作不会对存在数据依赖关系的操作进行重排序。
	- 比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
2. 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变
	- 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。
	- 重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行 a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。

---- 

## volatile & synchronized
1. volatile仅能使用在变量级别，synchronized可以使用在变量、方法、类级别。
2. volatile只能实现变量的*修改可见性*，不能保证*原子性*。synchronized可以保证*原子性*。
3. volatile不会造成*线程堵塞*。
4. volatile不会被*编译器优化*，效率较低。

## 实现原理
1. volatile变量修饰的共享变量，在进行写操作的时候会多出一个**lock**前缀的汇编指令。
2. 当对其进行写操作时，JVM就会向处理器发送一条Lock前缀的指令，把这个变量所在的缓存行的数据写回到系统内存。
3. 处理器会根据MESI**缓存一致性协议**来保证多CPU下的各个高速缓存中的数据的一致性(让其他CPU缓存中的该变量无效）。

### volatile写-读的内存语义

- 当**写**一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
- 当**读**一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。